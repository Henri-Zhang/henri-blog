---
title: 338. 比特位计数
---

## 题目描述

给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。

**示例 1:**

> **输入:** 2  
> **输出:** [0,1,1]

**示例 2:**

> **输入:** 5  
> **输出:** [0,1,1,2,1,2]

**进阶:**
`略。`

来源：[LeetCode](https://leetcode-cn.com/problems/counting-bits/)

## 思路

用笔写写画画就能找到规律。

| 数字 | 二进制 | 1 的个数 | 增加位数 |
| :--: | -----: | :------: | :------: |
|  0   |      0 |    0     |
|  1   |      1 |    1     |    ✔️    |
|  2   |     10 |    1     |
|  3   |     11 |    2     |
|  4   |    100 |    1     |    ✔️    |
|  5   |    101 |    2     |
|  6   |    110 |    2     |
|  7   |    111 |    3     |
|  8   |   1000 |    1     |    ✔️    |
|  9   |   1001 |    2     |
|  10  |   1010 |    2     |
|  11  |   1011 |    3     |
|  12  |   1100 |    2     |
|  13  |   1101 |    3     |
|  14  |   1110 |    3     |
|  15  |   1111 |    4     |
|  16  |  10000 |    1     |    ✔️    |

观察每次需要 **增加位数** 的时候，从这时开始到下一次 **增加位数** ，除了最高位的`1`，其他的和前面已有的数字一模一样。

## 解法

```js
/**
 * @param {number} num
 * @return {number[]}
 */
const countBits = num => {
  const result = [0];

  while (result.length <= num) {
    const len = result.length;

    for (let i = 0; i < len; i++) {
      result.push(result[i] + 1);

      if (result.length > num) break;
    }
  }

  return result;
};
```
