---
title: 746. 使用最小花费爬楼梯
---

## 题目描述

数组的每个索引做为一个阶梯，第  `i`个阶梯对应着一个非负数的体力花费值  `cost[i]`(索引从 0 开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

**示例 1:**

> **输入:** cost = [10, 15, 20]  
> **输出:** 15  
> **解释:** 最低花费是从 cost[1]开始，然后走两步即可到阶梯顶，一共花费 15。

**示例 2:**

> **输入:** cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]  
> **输出:** 6  
> **解释:** 最低花费方式是从 cost[0]开始，逐个经过那些 1，跳过 cost[3]，一共花费 6。

**注意：**

1. `cost` 的长度将会在 `[2, 1000]`。
2. 每一个 `cost[i]` 将会是一个 Integer 类型，范围为 `[0, 999]`。

来源：[LeetCode](https://leetcode-cn.com/problems/min-cost-climbing-stairs)

## 思路

典型的`动态规划`问题。

当只有两级阶梯的时候，可以从第一级或第二级直接登顶。那么最小花费就是`min(cost[0], cost[1])`。这就是 **边界**。

当超过两级时，登顶的前一级是倒数第一或第二级。那么登顶的最小花费，就是*登上倒数二级的最小花费加上倒数二级的花费*和*登上倒数一级的最小花费加上倒数一级的花费*之间的较小值。斜体部分即为 **最优子结构**。

得到`f(n) = min(cost[n - 1] + f(n - 1), cost[n - 2] + f(n - 2))`。这是 **状态转移方程**。

## 解法

```js
/**
 * @param {number[]} cost
 * @return {number}
 */
const minCostClimbingStairs = cost => {
  let a = 0;
  let b = 0;
  let result = Infinity;

  for (let i = 2; i <= cost.length; i++) {
    result = Math.min(a + cost[i - 2], b + cost[i - 1]);
    a = b;
    b = result;
  }

  return result;
};
```
